```js
function isValid(arr) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] <= 0) return "invalid";
  }
  for (var i = 2; i < arr.length; i++) {
    if (arr[i] !== arr[i - 1] + arr[i - 2]) return "invalid";
  }
  return "valid";
}

isValid([3, 5, 8, 13, 22, 35]);
```

## 執行流程

1. isValid 函式被呼叫後，[3, 5, 8, 13, 22, 35] 陣列的六位選手被傳進函式裡
2. 到函式第一行程式碼。執行第一個 for 迴圈。for 迴圈一接力規則為：
   `變數 i 設定起始值為 0，當 i 小於陣列最大長度即終止 (此陣列長度為 6)，每執行完一次迴圈 i 就加 1`
   接力賽 go!
3. 索引值 0 的數字 3 進到 for 迴圈一的 if 判斷式。當索引值代表數字小於等於 0 就回傳 `invalid`。數字 3 沒有小於等於 0，不 return
4. 索引值 1 的數字 5 進到 for 迴圈一的 if。5 未小於等於 0，不 return
5. 接著，索引值 2 的數字 8 跑進 for 迴圈一的 if。未小於等於 0，不 return
6. 輪到索引值 3 的數字 13 跑進 for 迴圈一的 if。未小於等於 0，不 return
7. 下一位，索引值 4 數字 22 跑進迴圈一的 if。未小於等於 0，不 return，交棒給下位選手
8. 輪到最後一位「索引值 5 的數字 35」的選手跑進 for 迴圈一的 if。未小於等於 0，不 return，
   恭喜數字們跑完第一場接力賽～
9. 現在選手們來到下一關 **_「for 迴圈二」_**。關卡規則更改為：
   `變數 i 設定起始值為 2，當 i 小於陣列最大長度即終止 (此陣列長度為 6) ，每執行完一次迴圈 i 就加 1`
   比賽開始！
10. 陣列索引值 2 的數字 8 進到 for 迴圈二 if 判斷式。當索引值 i 代表的數字不等於`「索引值 (i - 1) 的代表數字」加上「索引值 (i - 2) 的代表數字」`，就回傳 `invalid`。這場規則好像比較複雜一點，不過把第一位選手推出去阿其他人看它怎麼表演，跟著依樣畫葫蘆沒問題的。
11. 於是，數字 8 (索引值 2 號) 的選手，是否不等於數字 5 (索引值 2-1=1 號) 選手加上數字 3 (索引值 2-2=0 號) 選手呢？答案是：「等於」！所以不 return 喔。下一位～
12. 接著檢查數字 13 (索引值 3 號) 選手，是否不等於數字 8 (索引值 2 號) 選手加上數字 5 (索引值 1) 選手呢？還是等於，依然不 return。Next~
13. 再來是數字 22 (索引值 4 號) 選手上場。來看看它是否沒有等於數字 13 (索引值 3) 加上數字 8 (索引值 2)。登愣！真的沒有等於，條件符合，於是數字 22 被抓去勞改了（誤），剩下沒跑完的選手可以回家洗洗睡。
14. 總結：
    `isValid 函式在數字 22 跑到 for 迴圈二的 if 時 return "invalid"`，函式結束。
